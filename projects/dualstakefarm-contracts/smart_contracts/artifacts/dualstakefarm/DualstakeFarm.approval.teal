#pragma version 11
#pragma typetrack false

// smart_contracts.dualstakefarm.contract.DualstakeFarm.__algopy_entrypoint_with_init() -> uint64:
main:
    intcblock 1 0 8 30 10000
    bytecblock "global_remaining_blocks" "txn_fuel" 0x151f7c75 0x "manager" 0x0000000000000000 "ERR:NO FARM" "max_duration_days" "min_duration_blocks" "ix_pb" "plat_fee_pb" "txn_fee_pb" 0x6173615f6964
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/dualstakefarm/contract.py:100
    // self.manager = Txn.sender
    bytec 4 // "manager"
    txn Sender
    app_global_put
    // smart_contracts/dualstakefarm/contract.py:102
    // self.txn_fuel = UInt64(0)
    bytec_1 // "txn_fuel"
    intc_1 // 0
    app_global_put
    // smart_contracts/dualstakefarm/contract.py:103
    // self.global_remaining_blocks = UInt64(0)
    bytec_0 // "global_remaining_blocks"
    intc_1 // 0
    app_global_put
    // smart_contracts/dualstakefarm/contract.py:105
    // self.max_duration_days = UInt64(DEFAULT_MAX_DURATION_DAYS)
    bytec 7 // "max_duration_days"
    pushint 45 // 45
    app_global_put
    // smart_contracts/dualstakefarm/contract.py:106
    // self.min_duration_blocks = UInt64(DEFAULT_MIN_DURATION_BLOCKS)
    bytec 8 // "min_duration_blocks"
    intc_3 // 30
    app_global_put
    // smart_contracts/dualstakefarm/contract.py:108
    // self.ix_pb = UInt64(IX_REWARDS_PER_BLOCK)
    bytec 9 // "ix_pb"
    pushint 100 // 100
    app_global_put
    // smart_contracts/dualstakefarm/contract.py:109
    // self.plat_fee_pb = UInt64(PLATFORM_FEE_PER_BLOCK)
    bytec 10 // "plat_fee_pb"
    pushint 97 // 97
    app_global_put
    // smart_contracts/dualstakefarm/contract.py:110
    // self.txn_fee_pb = UInt64(TXN_FEE_PER_BLOCK)
    bytec 11 // "txn_fee_pb"
    pushint 3 // 3
    app_global_put

main_after_if_else@2:
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txn NumAppArgs
    bz main_bare_routing@20
    pushbytess 0xf3db04d9 0x08362178 0x5d64cbd0 0x74585dce 0x0290b820 0x092897d3 0x9a14a84f 0xe83a87ab 0x0d131751 0x7ccbe726 0xe9d827cc 0xe08048fc 0x15d69efc 0xc8a0654b 0xd299f2a0 // method "project_apr(application,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64,uint64)", method "get_algo_cost(application,asset,uint64)(uint64,uint64,uint64,uint64,uint64,uint64)", method "get_algo_cost_and_max_duration(application,asset,uint64)(uint64,uint64,uint64,uint64,uint64,uint64,uint64)", method "create_farm(application,asset,uint64,uint64)void", method "extend_duration_blocks(application,uint64)void", method "extend_amount_per_block(application,uint64)void", method "payout(application,uint64,bool)void", method "noop()void", method "withdraw_fees(uint64)void", method "optout(asset)void", method "update_max_duration_days(uint64)void", method "update_min_duration_blocks(uint64)void", method "get_state(application)(uint64,uint64,uint64,uint64)", method "log_states(uint64[])void", method "log_block_proposers(uint64,uint64)void"
    txna ApplicationArgs 0
    match main_project_apr_route@5 main_get_algo_cost_route@6 main_get_algo_cost_and_max_duration_route@7 main_create_farm_route@8 main_extend_duration_blocks_route@9 main_extend_amount_per_block_route@10 main_payout_route@11 main_noop_route@12 main_withdraw_fees_route@13 main_optout_route@14 main_update_max_duration_days_route@15 main_update_min_duration_blocks_route@16 main_get_state_route@17 main_log_states_route@18 main_log_block_proposers_route@19

main_after_if_else@24:
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    intc_1 // 0
    return

main_log_block_proposers_route@19:
    // smart_contracts/dualstakefarm/contract.py:543
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    // smart_contracts/dualstakefarm/contract.py:543
    // @abimethod(readonly=True)
    callsub log_block_proposers
    intc_0 // 1
    return

main_log_states_route@18:
    // smart_contracts/dualstakefarm/contract.py:534
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    // smart_contracts/dualstakefarm/contract.py:534
    // @abimethod(readonly=True)
    callsub log_states
    intc_0 // 1
    return

main_get_state_route@17:
    // smart_contracts/dualstakefarm/contract.py:530
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    txnas Applications
    // smart_contracts/dualstakefarm/contract.py:530
    // @abimethod(readonly=True)
    callsub get_state
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_update_min_duration_blocks_route@16:
    // smart_contracts/dualstakefarm/contract.py:525
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/dualstakefarm/contract.py:525
    // @abimethod
    callsub update_min_duration_blocks
    intc_0 // 1
    return

main_update_max_duration_days_route@15:
    // smart_contracts/dualstakefarm/contract.py:520
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/dualstakefarm/contract.py:520
    // @abimethod
    callsub update_max_duration_days
    intc_0 // 1
    return

main_optout_route@14:
    // smart_contracts/dualstakefarm/contract.py:509
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    txnas Assets
    // smart_contracts/dualstakefarm/contract.py:509
    // @abimethod
    callsub optout
    intc_0 // 1
    return

main_withdraw_fees_route@13:
    // smart_contracts/dualstakefarm/contract.py:493
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    // smart_contracts/dualstakefarm/contract.py:493
    // @abimethod
    callsub withdraw_fees
    intc_0 // 1
    return

main_noop_route@12:
    // smart_contracts/dualstakefarm/contract.py:489
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    intc_0 // 1
    return

main_payout_route@11:
    // smart_contracts/dualstakefarm/contract.py:419
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    txnas Applications
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    // smart_contracts/dualstakefarm/contract.py:419
    // @abimethod()
    callsub payout
    intc_0 // 1
    return

main_extend_amount_per_block_route@10:
    // smart_contracts/dualstakefarm/contract.py:395
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    txnas Applications
    txna ApplicationArgs 2
    btoi
    // smart_contracts/dualstakefarm/contract.py:395
    // @abimethod
    callsub extend_amount_per_block
    intc_0 // 1
    return

main_extend_duration_blocks_route@9:
    // smart_contracts/dualstakefarm/contract.py:354
    // @abimethod
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    txnas Applications
    txna ApplicationArgs 2
    btoi
    // smart_contracts/dualstakefarm/contract.py:354
    // @abimethod
    callsub extend_duration_blocks
    intc_0 // 1
    return

main_create_farm_route@8:
    // smart_contracts/dualstakefarm/contract.py:302
    // @abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    txnas Applications
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    // smart_contracts/dualstakefarm/contract.py:302
    // @abimethod()
    callsub create_farm
    intc_0 // 1
    return

main_get_algo_cost_and_max_duration_route@7:
    // smart_contracts/dualstakefarm/contract.py:253
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    txnas Applications
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    btoi
    // smart_contracts/dualstakefarm/contract.py:253
    // @abimethod(readonly=True)
    callsub get_algo_cost_and_max_duration
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_get_algo_cost_route@6:
    // smart_contracts/dualstakefarm/contract.py:247
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    txnas Applications
    txna ApplicationArgs 2
    btoi
    txnas Assets
    txna ApplicationArgs 3
    btoi
    // smart_contracts/dualstakefarm/contract.py:247
    // @abimethod(readonly=True)
    callsub get_algo_cost
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_project_apr_route@5:
    // smart_contracts/dualstakefarm/contract.py:144
    // @abimethod(readonly=True)
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txna ApplicationArgs 1
    btoi
    txnas Applications
    txna ApplicationArgs 2
    btoi
    // smart_contracts/dualstakefarm/contract.py:144
    // @abimethod(readonly=True)
    callsub project_apr
    bytec_2 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@20:
    // smart_contracts/dualstakefarm/contract.py:94-98
    // class DualstakeFarm(
    //     ARC4Contract,
    //     avm_version=11,
    //     state_totals=StateTotals(global_uints=40, global_bytes=24),
    // ):
    txn OnCompletion
    switch main___algopy_default_create@23 main_after_if_else@24 main_after_if_else@24 main_after_if_else@24 main_update@21 main_delete@22
    b main_after_if_else@24

main_delete@22:
    // smart_contracts/dualstakefarm/contract.py:116
    // @arc4.baremethod(allow_actions=("DeleteApplication",))
    txn ApplicationID
    assert // can only call when not creating
    callsub delete
    intc_0 // 1
    return

main_update@21:
    // smart_contracts/dualstakefarm/contract.py:112
    // @arc4.baremethod(allow_actions=("UpdateApplication",))
    txn ApplicationID
    assert // can only call when not creating
    callsub update
    intc_0 // 1
    return

main___algopy_default_create@23:
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts.common.send.axfer(asset: uint64, receiver: bytes, amount: uint64, fee: uint64) -> void:
axfer:
    // smart_contracts/common/send.py:18-19
    // @subroutine
    // def axfer(asset: Asset, receiver: Account, amount: UInt64, fee: UInt64) -> None:
    proto 4 0
    // smart_contracts/common/send.py:20-22
    // itxn.AssetTransfer(
    //     xfer_asset=asset, asset_receiver=receiver, asset_amount=amount, fee=fee
    // ).submit()
    itxn_begin
    frame_dig -2
    itxn_field AssetAmount
    frame_dig -3
    itxn_field AssetReceiver
    frame_dig -4
    itxn_field XferAsset
    // smart_contracts/common/send.py:20
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    frame_dig -1
    itxn_field Fee
    // smart_contracts/common/send.py:20-22
    // itxn.AssetTransfer(
    //     xfer_asset=asset, asset_receiver=receiver, asset_amount=amount, fee=fee
    // ).submit()
    itxn_submit
    // smart_contracts/common/send.py:23
    // return
    retsub


// smart_contracts.common.send.algo_pay(receiver: bytes, amount: uint64, fee: uint64) -> void:
algo_pay:
    // smart_contracts/common/send.py:38-39
    // @subroutine
    // def algo_pay(receiver: Account, amount: UInt64, fee: UInt64) -> None:
    proto 3 0
    // smart_contracts/common/send.py:40
    // itxn.Payment(receiver=receiver, amount=amount, fee=fee).submit()
    itxn_begin
    frame_dig -2
    itxn_field Amount
    frame_dig -3
    itxn_field Receiver
    intc_0 // pay
    itxn_field TypeEnum
    frame_dig -1
    itxn_field Fee
    itxn_submit
    // smart_contracts/common/send.py:41
    // return
    retsub


// smart_contracts.common.validate.axfer_amount_exact(axfer_txn_id: uint64, expected_asset: uint64, expected_amount: uint64) -> void:
axfer_amount_exact:
    // smart_contracts/common/validate.py:26-29
    // @subroutine
    // def axfer_amount_exact(
    //     axfer_txn_id: UInt64, expected_asset: Asset, expected_amount: UInt64
    // ) -> None:
    proto 3 0
    // smart_contracts/common/validate.py:17
    // axfer_txn = gtxn.AssetTransferTransaction(axfer_txn_idx)
    frame_dig -3
    gtxns TypeEnum
    pushint 4 // axfer
    ==
    assert // transaction type is axfer
    // smart_contracts/common/validate.py:18
    // custom.ensure(axfer_txn.xfer_asset == expected_asset, S("ERR:AXFER ID"))
    frame_dig -3
    gtxns XferAsset
    frame_dig -2
    ==
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz axfer_amount_exact_after_if_else@3
    // smart_contracts/common/validate.py:18
    // custom.ensure(axfer_txn.xfer_asset == expected_asset, S("ERR:AXFER ID"))
    pushbytes "ERR:AXFER ID"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

axfer_amount_exact_after_if_else@3:
    // smart_contracts/common/validate.py:20
    // axfer_txn.asset_receiver == Global.current_application_address,
    frame_dig -3
    gtxns AssetReceiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz axfer_amount_exact_after_if_else@7
    // smart_contracts/common/validate.py:21
    // S("ERR:AXFER RCV"),
    pushbytes "ERR:AXFER RCV"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

axfer_amount_exact_after_if_else@7:
    // smart_contracts/common/validate.py:23
    // return axfer_txn.asset_amount
    frame_dig -3
    gtxns AssetAmount
    // smart_contracts/common/validate.py:31
    // axfer(axfer_txn_id, expected_asset) >= expected_amount, S("ERR:AXFER AMT")
    frame_dig -1
    >=
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz axfer_amount_exact_after_if_else@11
    // smart_contracts/common/validate.py:31
    // axfer(axfer_txn_id, expected_asset) >= expected_amount, S("ERR:AXFER AMT")
    pushbytes "ERR:AXFER AMT"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

axfer_amount_exact_after_if_else@11:
    retsub


// smart_contracts.common.validate.payment_amount_exact(payment_txn_idx: uint64, expected_amount: uint64) -> void:
payment_amount_exact:
    // smart_contracts/common/validate.py:50-51
    // @subroutine
    // def payment_amount_exact(payment_txn_idx: UInt64, expected_amount: UInt64) -> None:
    proto 2 0
    // smart_contracts/common/validate.py:37
    // pay_txn = gtxn.PaymentTransaction(txn_idx)
    frame_dig -2
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/common/validate.py:39
    // pay_txn.receiver == Global.current_application_address,
    frame_dig -2
    gtxns Receiver
    global CurrentApplicationAddress
    ==
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz payment_amount_exact_after_if_else@3
    // smart_contracts/common/validate.py:40
    // S("ERR:PAY RCV"),
    pushbytes "ERR:PAY RCV"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

payment_amount_exact_after_if_else@3:
    // smart_contracts/common/validate.py:42
    // return pay_txn.amount
    frame_dig -2
    gtxns Amount
    // smart_contracts/common/validate.py:52
    // custom.ensure(payment(payment_txn_idx) == expected_amount, S("ERR:PAY AMT"))
    frame_dig -1
    ==
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz payment_amount_exact_after_if_else@7
    // smart_contracts/common/validate.py:52
    // custom.ensure(payment(payment_txn_idx) == expected_amount, S("ERR:PAY AMT"))
    pushbytes "ERR:PAY AMT"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

payment_amount_exact_after_if_else@7:
    retsub


// smart_contracts.common.round_time.get_round_time(min_round_sample: uint64) -> uint64, uint64:
get_round_time:
    // smart_contracts/common/round_time.py:22-23
    // @subroutine
    // def get_round_time(min_round_sample: UInt64) -> RoundTimeFraction:
    proto 1 2
    bytec_3 // ""
    dup
    // smart_contracts/common/round_time.py:24
    // first_accessible = math.safe_subtract(Txn.last_valid, UInt64(1001), UInt64(1))
    txn LastValid
    intc_0 // 1
    txn LastValid
    pushint 1001 // 1001
    // smart_contracts/common/math.py:14
    // return a - b if a > b else default
    >
    bz get_round_time_ternary_false@5
    frame_dig 2
    // smart_contracts/common/round_time.py:24
    // first_accessible = math.safe_subtract(Txn.last_valid, UInt64(1001), UInt64(1))
    pushint 1001 // 1001
    // smart_contracts/common/math.py:14
    // return a - b if a > b else default
    -
    frame_bury 0

get_round_time_ternary_merge@6:
    // smart_contracts/common/round_time.py:25
    // last_accessible = Txn.first_valid - UInt64(1)
    txn FirstValid
    intc_0 // 1
    -
    frame_bury 1
    // smart_contracts/common/round_time.py:26
    // if first_accessible > UInt64(1):
    frame_dig 0
    intc_0 // 1
    >
    bz get_round_time_after_if_else@2
    // smart_contracts/common/round_time.py:28
    // last_accessible - first_accessible >= min_round_sample,
    frame_dig 1
    frame_dig 0
    -
    frame_dig -1
    >=
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz get_round_time_after_if_else@2
    // smart_contracts/common/round_time.py:29
    // S("ERR:BLK RNGE"),
    pushbytes "ERR:BLK RNGE"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

get_round_time_after_if_else@2:
    // smart_contracts/common/round_time.py:31
    // block_delta = last_accessible - first_accessible
    frame_dig 1
    dup
    frame_dig 0
    dup
    cover 3
    -
    // smart_contracts/common/round_time.py:32
    // ts_delta = op.Block.blk_timestamp(last_accessible) - op.Block.blk_timestamp(
    swap
    block BlkTimestamp
    // smart_contracts/common/round_time.py:32-34
    // ts_delta = op.Block.blk_timestamp(last_accessible) - op.Block.blk_timestamp(
    //     first_accessible
    // )
    uncover 2
    block BlkTimestamp
    -
    // smart_contracts/common/round_time.py:35
    // return RoundTimeFraction(dt=ts_delta, dr=block_delta)
    frame_bury 0
    frame_bury 1
    retsub

get_round_time_ternary_false@5:
    frame_dig 3
    frame_bury 0
    b get_round_time_ternary_merge@6


// smart_contracts.dualstakefarm.contract.DualstakeFarm.update() -> void:
update:
    // smart_contracts/dualstakefarm/contract.py:112-113
    // @arc4.baremethod(allow_actions=("UpdateApplication",))
    // def update(self) -> None:
    proto 0 0
    // smart_contracts/dualstakefarm/contract.py:114
    // self.ensure_manager_caller()
    callsub ensure_manager_caller
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.delete() -> void:
delete:
    // smart_contracts/dualstakefarm/contract.py:116-117
    // @arc4.baremethod(allow_actions=("DeleteApplication",))
    // def delete(self) -> None:
    proto 0 0
    // smart_contracts/dualstakefarm/contract.py:118
    // self.ensure_manager_caller()
    callsub ensure_manager_caller
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.calc_tm_denom(a1: uint64, a2: uint64, v: uint64, amount: uint64) -> uint64:
calc_tm_denom:
    // smart_contracts/dualstakefarm/contract.py:120-123
    // @subroutine
    // def calc_tm_denom(
    //     self, a1: UInt64, a2: UInt64, v: UInt64, amount: UInt64
    // ) -> UInt64:
    proto 4 1
    // smart_contracts/dualstakefarm/contract.py:124
    // return op.btoi((B(a1) * B(a2) // B(v + get_tm2_net_amt(amount))).bytes)
    frame_dig -4
    itob
    frame_dig -3
    itob
    b*
    // smart_contracts/dualstakefarm/contract.py:29
    // return amt - (UInt64(30) * amt // UInt64(10000))
    intc_3 // 30
    frame_dig -1
    *
    intc 4 // 10000
    /
    frame_dig -1
    swap
    -
    // smart_contracts/dualstakefarm/contract.py:124
    // return op.btoi((B(a1) * B(a2) // B(v + get_tm2_net_amt(amount))).bytes)
    frame_dig -2
    +
    itob
    b/
    btoi
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.get_tinyman_algo_price_for_asset(tm2: uint64, tma: bytes, farm_amount: uint64) -> uint64:
get_tinyman_algo_price_for_asset:
    // smart_contracts/dualstakefarm/contract.py:126-132
    // @subroutine
    // def get_tinyman_algo_price_for_asset(
    //     self,
    //     tm2: Application,
    //     tma: Account,
    //     farm_amount: UInt64,
    // ) -> UInt64:
    proto 3 1
    // smart_contracts/dualstakefarm/contract.py:133
    // aid1, exists1 = op.AppLocal.get_ex_uint64(tma, tm2, b"asset_1_id")
    frame_dig -2
    frame_dig -3
    pushbytes 0x61737365745f315f6964
    app_local_get_ex
    // smart_contracts/dualstakefarm/contract.py:134
    // a1, exists2 = op.AppLocal.get_ex_uint64(tma, tm2, b"asset_1_reserves")
    frame_dig -2
    frame_dig -3
    pushbytes 0x61737365745f315f7265736572766573
    app_local_get_ex
    cover 2
    swap
    // smart_contracts/dualstakefarm/contract.py:135
    // a2, exists3 = op.AppLocal.get_ex_uint64(tma, tm2, b"asset_2_reserves")
    frame_dig -2
    frame_dig -3
    pushbytes 0x61737365745f325f7265736572766573
    app_local_get_ex
    cover 2
    swap
    // smart_contracts/dualstakefarm/contract.py:136
    // custom.ensure(exists1 and exists2 and exists3, S("ERR:TM STT"))
    bz get_tinyman_algo_price_for_asset_bool_false@4
    frame_dig 1
    bz get_tinyman_algo_price_for_asset_bool_false@4
    frame_dig 3
    bz get_tinyman_algo_price_for_asset_bool_false@4
    intc_0 // 1

get_tinyman_algo_price_for_asset_bool_merge@5:
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz get_tinyman_algo_price_for_asset_after_if_else@11
    // smart_contracts/dualstakefarm/contract.py:136
    // custom.ensure(exists1 and exists2 and exists3, S("ERR:TM STT"))
    pushbytes "ERR:TM STT"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

get_tinyman_algo_price_for_asset_after_if_else@11:
    // smart_contracts/dualstakefarm/contract.py:138
    // if aid1 != UInt64(0):
    frame_dig 0
    bz get_tinyman_algo_price_for_asset_else_body@7
    // smart_contracts/dualstakefarm/contract.py:139
    // ret = a2 - self.calc_tm_denom(a1, a2, a1, farm_amount) - UInt64(1)
    frame_dig 2
    dup
    frame_dig 4
    dup
    cover 3
    uncover 2
    frame_dig -1
    callsub calc_tm_denom
    -
    intc_0 // 1
    -

get_tinyman_algo_price_for_asset_after_if_else@8:
    // smart_contracts/dualstakefarm/contract.py:142
    // return ret
    frame_bury 0
    retsub

get_tinyman_algo_price_for_asset_else_body@7:
    // smart_contracts/dualstakefarm/contract.py:141
    // ret = a1 - self.calc_tm_denom(a1, a2, a2, farm_amount) - UInt64(1)
    frame_dig 2
    dup
    frame_dig 4
    dup
    frame_dig -1
    callsub calc_tm_denom
    -
    intc_0 // 1
    -
    b get_tinyman_algo_price_for_asset_after_if_else@8

get_tinyman_algo_price_for_asset_bool_false@4:
    intc_1 // 0
    b get_tinyman_algo_price_for_asset_bool_merge@5


// smart_contracts.dualstakefarm.contract.DualstakeFarm.project_apr(recipient_app: uint64, override_farm_amount: uint64) -> bytes:
project_apr:
    // smart_contracts/dualstakefarm/contract.py:144-149
    // @abimethod(readonly=True)
    // def project_apr(
    //     self,
    //     recipient_app: Application,
    //     override_farm_amount: UInt64,
    // ) -> APRBreakdown:
    proto 2 1
    intc_1 // 0
    bytec_3 // ""
    dup
    // smart_contracts/dualstakefarm/contract.py:150
    // tm2_app_id, exists2 = op.AppGlobal.get_ex_uint64(recipient_app, b"tm2_app_id")
    frame_dig -2
    pushbytes 0x746d325f6170705f6964
    app_global_get_ex
    swap
    // smart_contracts/dualstakefarm/contract.py:151
    // tm2_lp_addr, exists3 = op.AppGlobal.get_ex_bytes(recipient_app, b"lp_id")
    frame_dig -2
    pushbytes 0x6c705f6964
    app_global_get_ex
    swap
    // smart_contracts/dualstakefarm/contract.py:153
    // asa_id, exists1 = op.AppGlobal.get_ex_uint64(recipient_app, b"asa_id")
    frame_dig -2
    bytec 12 // 0x6173615f6964
    app_global_get_ex
    bury 1
    // smart_contracts/dualstakefarm/contract.py:154
    // staked, exists4 = op.AppGlobal.get_ex_uint64(recipient_app, b"staked")
    frame_dig -2
    pushbytes 0x7374616b6564
    app_global_get_ex
    cover 2
    swap
    // smart_contracts/dualstakefarm/contract.py:155
    // custom.ensure(exists1 and exists2 and exists3 and exists4, S("ERR:DS STT"))
    bz project_apr_bool_false@5
    frame_dig 3
    bz project_apr_bool_false@5
    frame_dig 5
    bz project_apr_bool_false@5
    frame_dig 7
    bz project_apr_bool_false@5
    intc_0 // 1

project_apr_bool_merge@6:
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz project_apr_after_if_else@17
    // smart_contracts/dualstakefarm/contract.py:155
    // custom.ensure(exists1 and exists2 and exists3 and exists4, S("ERR:DS STT"))
    pushbytes "ERR:DS STT"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

project_apr_after_if_else@17:
    // smart_contracts/dualstakefarm/contract.py:157
    // farm_amount = UInt64(0)
    intc_1 // 0
    frame_bury 1
    // smart_contracts/dualstakefarm/contract.py:158
    // if recipient_app in self.farms:
    frame_dig -2
    itob
    dup
    frame_bury 0
    box_len
    bury 1
    bz project_apr_after_if_else@8
    // smart_contracts/dualstakefarm/contract.py:159
    // farm_amount = self.farms[recipient_app].amount_per_block.native
    frame_dig 0
    box_get
    assert // check self.farms entry exists
    extract 8 8 // on error: Index access is out of bounds
    btoi
    frame_bury 1

project_apr_after_if_else@8:
    // smart_contracts/dualstakefarm/contract.py:162-166
    // self.get_tinyman_algo_price_for_asset(
    //     Application(tm2_app_id), Account(tm2_lp_addr), farm_amount
    // )
    // if farm_amount > UInt64(0)
    // else UInt64(0)
    frame_dig 1
    bz project_apr_ternary_false@10
    // smart_contracts/dualstakefarm/contract.py:163
    // Application(tm2_app_id), Account(tm2_lp_addr), farm_amount
    frame_dig 6
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/dualstakefarm/contract.py:162-164
    // self.get_tinyman_algo_price_for_asset(
    //     Application(tm2_app_id), Account(tm2_lp_addr), farm_amount
    // )
    frame_dig 4
    swap
    frame_dig 1
    callsub get_tinyman_algo_price_for_asset
    frame_bury 2

project_apr_ternary_merge@11:
    // smart_contracts/dualstakefarm/contract.py:170-174
    // self.get_tinyman_algo_price_for_asset(
    //     Application(tm2_app_id), Account(tm2_lp_addr), override_farm_amount
    // )
    // if override_farm_amount > UInt64(0)
    // else UInt64(0)
    frame_dig -1
    bz project_apr_ternary_false@13
    // smart_contracts/dualstakefarm/contract.py:171
    // Application(tm2_app_id), Account(tm2_lp_addr), override_farm_amount
    frame_dig 6
    dup
    len
    pushint 32 // 32
    ==
    assert // Address length is 32 bytes
    // smart_contracts/dualstakefarm/contract.py:170-172
    // self.get_tinyman_algo_price_for_asset(
    //     Application(tm2_app_id), Account(tm2_lp_addr), override_farm_amount
    // )
    frame_dig 4
    swap
    frame_dig -1
    callsub get_tinyman_algo_price_for_asset

project_apr_ternary_merge@14:
    // smart_contracts/dualstakefarm/contract.py:177-178
    // # balance is staked+fees. Use this to calculate blocks (nom in % of online)
    // balance = recipient_app.address.balance
    frame_dig -2
    app_params_get AppAddress
    assert // application exists
    acct_params_get AcctBalance
    assert // account funded
    // smart_contracts/dualstakefarm/contract.py:179
    // total_online_stake = BigUInt(op.online_stake())
    online_stake
    itob
    // smart_contracts/dualstakefarm/contract.py:181
    // current_block_rewards = op.Block.blk_bonus(Txn.first_valid - UInt64(1))
    txn FirstValid
    intc_0 // 1
    -
    block BlkBonus
    // smart_contracts/dualstakefarm/contract.py:184
    // rt_fraction = round_time.get_round_time(UInt64(MIN_ROUND_SAMPLE))
    pushint 500 // 500
    callsub get_round_time
    // smart_contracts/dualstakefarm/contract.py:185
    // avg_round_time = UInt64(10000) * rt_fraction.dt // rt_fraction.dr
    intc 4 // 10000
    dig 2
    *
    dig 1
    /
    // smart_contracts/dualstakefarm/contract.py:187
    // UInt64(86400) * UInt64(365) * rt_fraction.dr // rt_fraction.dt
    pushint 31536000 // 31536000
    uncover 2
    *
    uncover 2
    /
    // smart_contracts/dualstakefarm/contract.py:186-188
    // global_yearly_blocks_produced = BigUInt(
    //     UInt64(86400) * UInt64(365) * rt_fraction.dr // rt_fraction.dt
    // )
    itob
    // smart_contracts/dualstakefarm/contract.py:191
    // global_yearly_blocks_produced * balance // total_online_stake
    uncover 4
    itob
    swap
    dig 1
    b*
    // smart_contracts/dualstakefarm/contract.py:190-192
    // own_yearly_blocks_produced = (
    //     global_yearly_blocks_produced * balance // total_online_stake
    // )
    dig 4
    // smart_contracts/dualstakefarm/contract.py:191
    // global_yearly_blocks_produced * balance // total_online_stake
    b/
    // smart_contracts/dualstakefarm/contract.py:194
    // base_rewards = (current_block_rewards) * own_yearly_blocks_produced
    uncover 3
    itob
    dup
    dig 2
    b*
    // smart_contracts/dualstakefarm/contract.py:195
    // base_apr_bps = UInt64(10000) * base_rewards // staked
    intc 4 // 10000
    itob
    dup
    uncover 2
    b*
    frame_dig 8
    itob
    swap
    dig 1
    b/
    // smart_contracts/dualstakefarm/contract.py:197
    // farm_rewards = (farm_amount_algo) * own_yearly_blocks_produced
    frame_dig 2
    itob
    dup
    dig 6
    b*
    // smart_contracts/dualstakefarm/contract.py:198
    // farm_apr_bps = UInt64(10000) * farm_rewards // staked
    dig 4
    b*
    dig 3
    b/
    // smart_contracts/dualstakefarm/contract.py:200
    // override_farm_rewards = (override_farm_amount_algo) * own_yearly_blocks_produced
    uncover 10
    itob
    dup
    dig 8
    b*
    // smart_contracts/dualstakefarm/contract.py:201
    // override_farm_apr_bps = UInt64(10000) * override_farm_rewards // staked
    uncover 6
    b*
    dig 5
    b/
    // smart_contracts/dualstakefarm/contract.py:211
    // current_farm_amount=arc4.UInt64(farm_amount),
    frame_dig 1
    itob
    // smart_contracts/dualstakefarm/contract.py:213
    // override_farm_amount=arc4.UInt64(override_farm_amount),
    frame_dig -1
    itob
    // smart_contracts/dualstakefarm/contract.py:207
    // avg_round_time=arc4.UInt64(avg_round_time),
    uncover 11
    itob
    // smart_contracts/dualstakefarm/contract.py:206
    // online_stake=arc4.UInt64(total_online_stake),
    dig 12
    len
    intc_2 // 8
    <=
    assert // overflow
    intc_2 // 8
    bzero
    uncover 13
    dig 1
    b|
    // smart_contracts/dualstakefarm/contract.py:208
    // expected_yearly_blocks=arc4.UInt64(own_yearly_blocks_produced),
    dig 12
    len
    intc_2 // 8
    <=
    assert // overflow
    uncover 12
    dig 2
    b|
    // smart_contracts/dualstakefarm/contract.py:215
    // base_apr_bps=arc4.UInt64(base_apr_bps),
    dig 10
    len
    intc_2 // 8
    <=
    assert // overflow
    uncover 10
    dig 3
    b|
    // smart_contracts/dualstakefarm/contract.py:216
    // farm_apr_bps=arc4.UInt64(farm_apr_bps),
    dig 9
    len
    intc_2 // 8
    <=
    assert // overflow
    uncover 9
    dig 4
    b|
    // smart_contracts/dualstakefarm/contract.py:217
    // override_farm_apr_bps=arc4.UInt64(override_farm_apr_bps),
    dig 8
    len
    intc_2 // 8
    <=
    assert // overflow
    uncover 8
    uncover 5
    b|
    // smart_contracts/dualstakefarm/contract.py:203-218
    // return APRBreakdown(
    //     balance=arc4.UInt64(balance),
    //     staked=arc4.UInt64(staked),
    //     online_stake=arc4.UInt64(total_online_stake),
    //     avg_round_time=arc4.UInt64(avg_round_time),
    //     expected_yearly_blocks=arc4.UInt64(own_yearly_blocks_produced),
    //     current_block_bonus=arc4.UInt64(current_block_rewards),
    //     current_avg_block_payout=arc4.UInt64(0),
    //     current_farm_amount=arc4.UInt64(farm_amount),
    //     current_farm_amount_algo=arc4.UInt64(farm_amount_algo),
    //     override_farm_amount=arc4.UInt64(override_farm_amount),
    //     override_farm_amount_algo=arc4.UInt64(override_farm_amount_algo),
    //     base_apr_bps=arc4.UInt64(base_apr_bps),
    //     farm_apr_bps=arc4.UInt64(farm_apr_bps),
    //     override_farm_apr_bps=arc4.UInt64(override_farm_apr_bps),
    // )
    uncover 12
    uncover 11
    concat
    uncover 11
    concat
    // smart_contracts/dualstakefarm/contract.py:210
    // current_avg_block_payout=arc4.UInt64(0),
    bytec 5 // 0x0000000000000000
    // smart_contracts/dualstakefarm/contract.py:203-218
    // return APRBreakdown(
    //     balance=arc4.UInt64(balance),
    //     staked=arc4.UInt64(staked),
    //     online_stake=arc4.UInt64(total_online_stake),
    //     avg_round_time=arc4.UInt64(avg_round_time),
    //     expected_yearly_blocks=arc4.UInt64(own_yearly_blocks_produced),
    //     current_block_bonus=arc4.UInt64(current_block_rewards),
    //     current_avg_block_payout=arc4.UInt64(0),
    //     current_farm_amount=arc4.UInt64(farm_amount),
    //     current_farm_amount_algo=arc4.UInt64(farm_amount_algo),
    //     override_farm_amount=arc4.UInt64(override_farm_amount),
    //     override_farm_amount_algo=arc4.UInt64(override_farm_amount_algo),
    //     base_apr_bps=arc4.UInt64(base_apr_bps),
    //     farm_apr_bps=arc4.UInt64(farm_apr_bps),
    //     override_farm_apr_bps=arc4.UInt64(override_farm_apr_bps),
    // )
    concat
    uncover 8
    concat
    uncover 9
    concat
    uncover 7
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    frame_bury 0
    retsub

project_apr_ternary_false@13:
    // smart_contracts/dualstakefarm/contract.py:174
    // else UInt64(0)
    intc_1 // 0
    b project_apr_ternary_merge@14

project_apr_ternary_false@10:
    // smart_contracts/dualstakefarm/contract.py:166
    // else UInt64(0)
    intc_1 // 0
    frame_bury 2
    b project_apr_ternary_merge@11

project_apr_bool_false@5:
    intc_1 // 0
    b project_apr_bool_merge@6


// smart_contracts.dualstakefarm.contract.DualstakeFarm.calculate_algo_cost(recipient_app: uint64, farm_asset: uint64, duration_blocks: uint64) -> bytes:
calculate_algo_cost:
    // smart_contracts/dualstakefarm/contract.py:220-223
    // @subroutine
    // def calculate_algo_cost(
    //     self, recipient_app: Application, farm_asset: Asset, duration_blocks: UInt64
    // ) -> AlgoCost:
    proto 3 1
    // smart_contracts/dualstakefarm/contract.py:226
    // if Global.current_application_address.is_opted_in(farm_asset)
    global CurrentApplicationAddress
    frame_dig -2
    asset_holding_get AssetBalance
    bury 1
    // smart_contracts/dualstakefarm/contract.py:225-227
    // UInt64(0)
    // if Global.current_application_address.is_opted_in(farm_asset)
    // else Global.asset_opt_in_min_balance
    bz calculate_algo_cost_ternary_false@2
    // smart_contracts/dualstakefarm/contract.py:225
    // UInt64(0)
    intc_1 // 0

calculate_algo_cost_ternary_merge@3:
    // smart_contracts/dualstakefarm/contract.py:230
    // UInt64(0) if recipient_app in self.farms else UInt64(5 * 8 * 400 + 2500)
    frame_dig -3
    itob
    box_len
    bury 1
    pushint 18500 // 18500
    intc_1 // 0
    // smart_contracts/dualstakefarm/contract.py:229-231
    // box_mbr = (
    //     UInt64(0) if recipient_app in self.farms else UInt64(5 * 8 * 400 + 2500)
    // )  # box size is 1+4 uint64s
    uncover 2
    // smart_contracts/dualstakefarm/contract.py:230
    // UInt64(0) if recipient_app in self.farms else UInt64(5 * 8 * 400 + 2500)
    select
    // smart_contracts/dualstakefarm/contract.py:233
    // ix_cost = self.get_ix_rewards_per_block() * duration_blocks
    callsub get_ix_rewards_per_block
    frame_dig -1
    *
    // smart_contracts/dualstakefarm/contract.py:234
    // txn_fee_cost = self.get_txn_fee_per_block() * duration_blocks
    callsub get_txn_fee_per_block
    frame_dig -1
    *
    // smart_contracts/dualstakefarm/contract.py:570
    // return self.plat_fee_pb * Global.min_txn_fee
    intc_1 // 0
    bytec 10 // "plat_fee_pb"
    app_global_get_ex
    assert // check self.plat_fee_pb exists
    global MinTxnFee
    *
    // smart_contracts/dualstakefarm/contract.py:235
    // platform_cost = self.get_platform_fee_per_block() * duration_blocks
    frame_dig -1
    *
    // smart_contracts/dualstakefarm/contract.py:236
    // total_cost = ix_cost + txn_fee_cost + platform_cost
    dig 2
    dig 2
    +
    dig 1
    +
    // smart_contracts/dualstakefarm/contract.py:239
    // total_cost=arc4.UInt64(total_cost),
    itob
    // smart_contracts/dualstakefarm/contract.py:241
    // optin_cost=arc4.UInt64(optin_mbr),
    uncover 5
    itob
    // smart_contracts/dualstakefarm/contract.py:240
    // box_cost=arc4.UInt64(box_mbr),
    uncover 5
    itob
    // smart_contracts/dualstakefarm/contract.py:244
    // platform_cost=arc4.UInt64(platform_cost),
    uncover 3
    itob
    // smart_contracts/dualstakefarm/contract.py:243
    // ix_cost=arc4.UInt64(ix_cost),
    uncover 5
    itob
    // smart_contracts/dualstakefarm/contract.py:242
    // txn_fee_cost=arc4.UInt64(txn_fee_cost),
    uncover 5
    itob
    // smart_contracts/dualstakefarm/contract.py:238-245
    // return AlgoCost(
    //     total_cost=arc4.UInt64(total_cost),
    //     box_cost=arc4.UInt64(box_mbr),
    //     optin_cost=arc4.UInt64(optin_mbr),
    //     txn_fee_cost=arc4.UInt64(txn_fee_cost),
    //     ix_cost=arc4.UInt64(ix_cost),
    //     platform_cost=arc4.UInt64(platform_cost),
    // )
    uncover 5
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    retsub

calculate_algo_cost_ternary_false@2:
    // smart_contracts/dualstakefarm/contract.py:227
    // else Global.asset_opt_in_min_balance
    global AssetOptInMinBalance
    b calculate_algo_cost_ternary_merge@3


// smart_contracts.dualstakefarm.contract.DualstakeFarm.get_algo_cost(recipient_app: uint64, farm_asset: uint64, duration_blocks: uint64) -> bytes:
get_algo_cost:
    // smart_contracts/dualstakefarm/contract.py:247-250
    // @abimethod(readonly=True)
    // def get_algo_cost(
    //     self, recipient_app: Application, farm_asset: Asset, duration_blocks: UInt64
    // ) -> AlgoCost:
    proto 3 1
    // smart_contracts/dualstakefarm/contract.py:251
    // return self.calculate_algo_cost(recipient_app, farm_asset, duration_blocks)
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub calculate_algo_cost
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.get_algo_cost_and_max_duration(recipient_app: uint64, farm_asset: uint64, duration_blocks: uint64) -> bytes:
get_algo_cost_and_max_duration:
    // smart_contracts/dualstakefarm/contract.py:253-256
    // @abimethod(readonly=True)
    // def get_algo_cost_and_max_duration(
    //     self, recipient_app: Application, farm_asset: Asset, duration_blocks: UInt64
    // ) -> AlgoCostAndMaxDuration:
    proto 3 1
    // smart_contracts/dualstakefarm/contract.py:257
    // cost = self.calculate_algo_cost(recipient_app, farm_asset, duration_blocks)
    frame_dig -3
    frame_dig -2
    frame_dig -1
    callsub calculate_algo_cost
    // smart_contracts/dualstakefarm/contract.py:259
    // total_cost=cost.total_cost,
    dup
    extract 0 8 // on error: Index access is out of bounds
    // smart_contracts/dualstakefarm/contract.py:261
    // optin_cost=cost.optin_cost,
    dig 1
    extract 8 8 // on error: Index access is out of bounds
    // smart_contracts/dualstakefarm/contract.py:260
    // box_cost=cost.box_cost,
    dig 2
    extract 16 8 // on error: Index access is out of bounds
    // smart_contracts/dualstakefarm/contract.py:264
    // platform_cost=cost.platform_cost,
    dig 3
    extract 24 8 // on error: Index access is out of bounds
    // smart_contracts/dualstakefarm/contract.py:263
    // ix_cost=cost.ix_cost,
    dig 4
    extract 32 8 // on error: Index access is out of bounds
    // smart_contracts/dualstakefarm/contract.py:262
    // txn_fee_cost=cost.txn_fee_cost,
    uncover 5
    extract 40 8 // on error: Index access is out of bounds
    // smart_contracts/dualstakefarm/contract.py:265
    // max_duration=arc4.UInt64(self.get_max_duration(recipient_app)),
    frame_dig -3
    callsub get_max_duration
    itob
    // smart_contracts/dualstakefarm/contract.py:258-266
    // return AlgoCostAndMaxDuration(
    //     total_cost=cost.total_cost,
    //     box_cost=cost.box_cost,
    //     optin_cost=cost.optin_cost,
    //     txn_fee_cost=cost.txn_fee_cost,
    //     ix_cost=cost.ix_cost,
    //     platform_cost=cost.platform_cost,
    //     max_duration=arc4.UInt64(self.get_max_duration(recipient_app)),
    // )
    uncover 6
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.get_max_duration(recipient_app: uint64) -> uint64:
get_max_duration:
    // smart_contracts/dualstakefarm/contract.py:268-269
    // @subroutine
    // def get_max_duration(self, recipient_app: Application) -> UInt64:
    proto 1 1
    // smart_contracts/dualstakefarm/contract.py:274
    // ds_balance = BigUInt(recipient_app.address.balance)
    frame_dig -1
    app_params_get AppAddress
    assert // application exists
    acct_params_get AcctBalance
    assert // account funded
    itob
    // smart_contracts/dualstakefarm/contract.py:275
    // total_online_stake = BigUInt(op.online_stake())
    online_stake
    itob
    // smart_contracts/dualstakefarm/contract.py:276-277
    // # round_time = (dt == time2 - time1) / (dr == block2 - block1)
    // rt_fraction = round_time.get_round_time(UInt64(MIN_ROUND_SAMPLE))
    pushint 500 // 500
    callsub get_round_time
    // smart_contracts/dualstakefarm/contract.py:280-281
    // UInt64(86400)
    // * UInt64(DEFAULT_MAX_DURATION_DAYS)
    pushint 3888000 // 3888000
    // smart_contracts/dualstakefarm/contract.py:280-282
    // UInt64(86400)
    // * UInt64(DEFAULT_MAX_DURATION_DAYS)
    // * rt_fraction.dr
    *
    // smart_contracts/dualstakefarm/contract.py:280-283
    // UInt64(86400)
    // * UInt64(DEFAULT_MAX_DURATION_DAYS)
    // * rt_fraction.dr
    // // rt_fraction.dt
    swap
    /
    // smart_contracts/dualstakefarm/contract.py:278-284
    // # blocks produced = 45 days in seconds / round_time
    // blocks_produced = BigUInt(
    //     UInt64(86400)
    //     * UInt64(DEFAULT_MAX_DURATION_DAYS)
    //     * rt_fraction.dr
    //     // rt_fraction.dt
    // )
    itob
    // smart_contracts/dualstakefarm/contract.py:285-287
    // # max duration = percentage_of_stake * blocks produced in 45 days
    // # = own_stake * blocks_produced / total_stake
    // max_duration = ds_balance * blocks_produced // total_online_stake
    uncover 2
    b*
    swap
    b/
    // smart_contracts/dualstakefarm/contract.py:289
    // UInt64(DEFAULT_MIN_DURATION_BLOCKS), op.btoi(max_duration.bytes)
    btoi
    intc_3 // 30
    // smart_contracts/common/math.py:9
    // return a if a > b else b
    dig 1
    >
    // smart_contracts/dualstakefarm/contract.py:289
    // UInt64(DEFAULT_MIN_DURATION_BLOCKS), op.btoi(max_duration.bytes)
    intc_3 // 30
    // smart_contracts/common/math.py:9
    // return a if a > b else b
    swap
    select
    // smart_contracts/dualstakefarm/contract.py:288-290
    // return math.max(
    //     UInt64(DEFAULT_MIN_DURATION_BLOCKS), op.btoi(max_duration.bytes)
    // )
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.validate_duration(recipient_app: uint64, duration_blocks: uint64) -> void:
validate_duration:
    // smart_contracts/dualstakefarm/contract.py:292-295
    // @subroutine
    // def validate_duration(
    //     self, recipient_app: Application, duration_blocks: UInt64
    // ) -> None:
    proto 2 0
    // smart_contracts/dualstakefarm/contract.py:296
    // allowed_duration = self.get_max_duration(recipient_app)
    frame_dig -2
    callsub get_max_duration
    dup
    // smart_contracts/dualstakefarm/contract.py:297
    // if allowed_duration < duration_blocks:
    frame_dig -1
    <
    bz validate_duration_after_if_else@2
    // smart_contracts/dualstakefarm/contract.py:298
    // log(allowed_duration)
    frame_dig 0
    itob
    log
    // smart_contracts/dualstakefarm/contract.py:299
    // log("ERR:DURATION")
    pushbytes "ERR:DURATION"
    log
    // smart_contracts/dualstakefarm/contract.py:300
    // op.err()
    err

validate_duration_after_if_else@2:
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.create_farm(recipient_app: uint64, farm_asset: uint64, amount_per_block: uint64, duration_blocks: uint64) -> void:
create_farm:
    // smart_contracts/dualstakefarm/contract.py:302-309
    // @abimethod()
    // def create_farm(
    //     self,
    //     recipient_app: Application,
    //     farm_asset: Asset,
    //     amount_per_block: UInt64,
    //     duration_blocks: UInt64,
    // ) -> None:
    proto 4 0
    // smart_contracts/dualstakefarm/contract.py:310-311
    // # reject if farm exists already
    // custom.ensure(recipient_app not in self.farms, S("ERR:EXISTS"))
    frame_dig -4
    itob
    dup
    box_len
    bury 1
    // smart_contracts/common/custom.py:11
    // if not cond:
    bz create_farm_after_if_else@7
    // smart_contracts/dualstakefarm/contract.py:310-311
    // # reject if farm exists already
    // custom.ensure(recipient_app not in self.farms, S("ERR:EXISTS"))
    pushbytes "ERR:EXISTS"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

create_farm_after_if_else@7:
    // smart_contracts/dualstakefarm/contract.py:313
    // custom.ensure(Txn.group_index > 0, S("ERR:NO PAY"))
    txn GroupIndex
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz create_farm_after_if_else@11
    // smart_contracts/dualstakefarm/contract.py:313
    // custom.ensure(Txn.group_index > 0, S("ERR:NO PAY"))
    pushbytes "ERR:NO PAY"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

create_farm_after_if_else@11:
    // smart_contracts/dualstakefarm/contract.py:317
    // Txn.group_index - UInt64(1),  # previous txn
    txn GroupIndex
    intc_0 // 1
    -
    // smart_contracts/dualstakefarm/contract.py:318-320
    // self.calculate_algo_cost(
    //     recipient_app, farm_asset, duration_blocks
    // ).total_cost.native,
    frame_dig -4
    frame_dig -3
    frame_dig -1
    callsub calculate_algo_cost
    extract 0 8 // on error: Index access is out of bounds
    btoi
    // smart_contracts/dualstakefarm/contract.py:315-321
    // # validate ALGO payment. positioned before so it can cover optin and box MBR
    // validate.payment_amount_exact(
    //     Txn.group_index - UInt64(1),  # previous txn
    //     self.calculate_algo_cost(
    //         recipient_app, farm_asset, duration_blocks
    //     ).total_cost.native,
    // )
    callsub payment_amount_exact
    // smart_contracts/dualstakefarm/contract.py:327
    // Txn.group_index + UInt64(1),  # next txn
    txn GroupIndex
    intc_0 // 1
    +
    // smart_contracts/dualstakefarm/contract.py:329
    // amount_per_block * duration_blocks,
    frame_dig -2
    frame_dig -1
    *
    // smart_contracts/dualstakefarm/contract.py:323-330
    // # validate ASA deposit. positioned after app call so we can opt in if needed
    // # don't do as I do, if you use this pattern you can get exploited if another method validates an asa payment at (-1)
    // # and if you do do as I do, ensure all your axfers are expected at +1
    // validate.axfer_amount_exact(
    //     Txn.group_index + UInt64(1),  # next txn
    //     farm_asset,
    //     amount_per_block * duration_blocks,
    // )
    frame_dig -3
    swap
    callsub axfer_amount_exact
    // smart_contracts/dualstakefarm/contract.py:332
    // self.validate_duration(recipient_app, duration_blocks)
    frame_dig -4
    frame_dig -1
    callsub validate_duration
    // smart_contracts/dualstakefarm/contract.py:334-335
    // # Check recipient app state
    // recipient_asa_id, exists = op.AppGlobal.get_ex_uint64(recipient_app, b"asa_id")
    frame_dig -4
    bytec 12 // 0x6173615f6964
    app_global_get_ex
    pop
    // smart_contracts/dualstakefarm/contract.py:336
    // custom.ensure(recipient_asa_id == farm_asset.id, S("ERR:APP ASA"))
    frame_dig -3
    ==
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz create_farm_after_if_else@15
    // smart_contracts/dualstakefarm/contract.py:336
    // custom.ensure(recipient_asa_id == farm_asset.id, S("ERR:APP ASA"))
    pushbytes "ERR:APP ASA"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

create_farm_after_if_else@15:
    // smart_contracts/dualstakefarm/contract.py:338-339
    // # optin if needed
    // if not Global.current_application_address.is_opted_in(farm_asset):
    global CurrentApplicationAddress
    frame_dig -3
    asset_holding_get AssetBalance
    bury 1
    bnz create_farm_after_if_else@2
    // smart_contracts/common/send.py:6
    // axfer(asset, Global.current_application_address, UInt64(0), fee)
    frame_dig -3
    global CurrentApplicationAddress
    intc_1 // 0
    // smart_contracts/dualstakefarm/contract.py:340
    // send.optin(farm_asset, UInt64(0))
    dup
    // smart_contracts/common/send.py:6
    // axfer(asset, Global.current_application_address, UInt64(0), fee)
    callsub axfer

create_farm_after_if_else@2:
    // smart_contracts/dualstakefarm/contract.py:344
    // farm_asset=arc4.UInt64(farm_asset.id),
    frame_dig -3
    itob
    // smart_contracts/dualstakefarm/contract.py:345
    // amount_per_block=arc4.UInt64(amount_per_block),
    frame_dig -2
    itob
    // smart_contracts/dualstakefarm/contract.py:346
    // remaining_duration_blocks=arc4.UInt64(duration_blocks),
    frame_dig -1
    itob
    // smart_contracts/dualstakefarm/contract.py:347
    // last_block_paid=arc4.UInt64(Global.round + 1),
    global Round
    intc_0 // 1
    +
    itob
    // smart_contracts/dualstakefarm/contract.py:342-348
    // # create farm box entry
    // self.farms[recipient_app] = FarmState(
    //     farm_asset=arc4.UInt64(farm_asset.id),
    //     amount_per_block=arc4.UInt64(amount_per_block),
    //     remaining_duration_blocks=arc4.UInt64(duration_blocks),
    //     last_block_paid=arc4.UInt64(Global.round + 1),
    // )
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    frame_dig 0
    swap
    box_put
    // smart_contracts/dualstakefarm/contract.py:350-351
    // # add to global txn fuel
    // self.txn_fuel = self.txn_fuel + self.get_spend_per_block() * duration_blocks
    intc_1 // 0
    bytec_1 // "txn_fuel"
    app_global_get_ex
    assert // check self.txn_fuel exists
    // smart_contracts/dualstakefarm/contract.py:562
    // return self.get_txn_fee_per_block() + self.get_ix_rewards_per_block()
    callsub get_txn_fee_per_block
    callsub get_ix_rewards_per_block
    +
    // smart_contracts/dualstakefarm/contract.py:350-351
    // # add to global txn fuel
    // self.txn_fuel = self.txn_fuel + self.get_spend_per_block() * duration_blocks
    frame_dig -1
    *
    +
    bytec_1 // "txn_fuel"
    swap
    app_global_put
    // smart_contracts/dualstakefarm/contract.py:352
    // self.global_remaining_blocks = self.global_remaining_blocks + duration_blocks
    intc_1 // 0
    bytec_0 // "global_remaining_blocks"
    app_global_get_ex
    assert // check self.global_remaining_blocks exists
    frame_dig -1
    +
    bytec_0 // "global_remaining_blocks"
    swap
    app_global_put
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.extend_duration_blocks(recipient_app: uint64, duration_blocks: uint64) -> void:
extend_duration_blocks:
    // smart_contracts/dualstakefarm/contract.py:354-359
    // @abimethod
    // def extend_duration_blocks(
    //     self,
    //     recipient_app: Application,
    //     duration_blocks: UInt64,
    // ) -> None:
    proto 2 0
    // smart_contracts/dualstakefarm/contract.py:360
    // custom.ensure(recipient_app in self.farms, S("ERR:NO FARM"))
    frame_dig -2
    itob
    dup
    box_len
    bury 1
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz extend_duration_blocks_after_if_else@3
    // smart_contracts/dualstakefarm/contract.py:360
    // custom.ensure(recipient_app in self.farms, S("ERR:NO FARM"))
    bytec 6 // "ERR:NO FARM"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

extend_duration_blocks_after_if_else@3:
    // smart_contracts/dualstakefarm/contract.py:362
    // state = self.farms[recipient_app].copy()
    frame_dig 0
    dup
    box_get
    assert // check self.farms entry exists
    // smart_contracts/dualstakefarm/contract.py:363
    // farm_asset = Asset(state.farm_asset.native)
    dup
    extract 0 8 // on error: Index access is out of bounds
    btoi
    // smart_contracts/dualstakefarm/contract.py:367
    // Txn.group_index - UInt64(1),  # previous txn
    txn GroupIndex
    intc_0 // 1
    -
    // smart_contracts/dualstakefarm/contract.py:368-370
    // self.calculate_algo_cost(
    //     recipient_app, farm_asset, duration_blocks
    // ).total_cost.native,
    frame_dig -2
    dig 2
    frame_dig -1
    callsub calculate_algo_cost
    extract 0 8 // on error: Index access is out of bounds
    btoi
    // smart_contracts/dualstakefarm/contract.py:365-371
    // # validate ALGO and ASA payments. keeping create_farm before/after structure for simplicity
    // validate.payment_amount_exact(
    //     Txn.group_index - UInt64(1),  # previous txn
    //     self.calculate_algo_cost(
    //         recipient_app, farm_asset, duration_blocks
    //     ).total_cost.native,
    // )
    callsub payment_amount_exact
    // smart_contracts/dualstakefarm/contract.py:374
    // Txn.group_index + UInt64(1),  # next txn
    txn GroupIndex
    intc_0 // 1
    +
    // smart_contracts/dualstakefarm/contract.py:376
    // state.amount_per_block.native * duration_blocks,
    dig 2
    extract 8 8 // on error: Index access is out of bounds
    btoi
    frame_dig -1
    *
    // smart_contracts/dualstakefarm/contract.py:373-377
    // validate.axfer_amount_exact(
    //     Txn.group_index + UInt64(1),  # next txn
    //     farm_asset,
    //     state.amount_per_block.native * duration_blocks,
    // )
    swap
    cover 2
    callsub axfer_amount_exact
    // smart_contracts/dualstakefarm/contract.py:380
    // recipient_app, state.remaining_duration_blocks.native + duration_blocks
    dup
    extract 16 8 // on error: Index access is out of bounds
    btoi
    frame_dig -1
    +
    // smart_contracts/dualstakefarm/contract.py:379-381
    // self.validate_duration(
    //     recipient_app, state.remaining_duration_blocks.native + duration_blocks
    // )
    frame_dig -2
    dig 1
    callsub validate_duration
    // smart_contracts/dualstakefarm/contract.py:383-386
    // # adjust remaining blocks in state
    // state.remaining_duration_blocks = arc4.UInt64(
    //     state.remaining_duration_blocks.native + duration_blocks
    // )
    itob
    replace2 16
    // smart_contracts/dualstakefarm/contract.py:387-388
    // # save state
    // self.farms[recipient_app] = state.copy()
    box_put
    // smart_contracts/dualstakefarm/contract.py:390-391
    // # adjust txn fuel remaining
    // self.txn_fuel = self.txn_fuel + self.get_spend_per_block() * duration_blocks
    intc_1 // 0
    bytec_1 // "txn_fuel"
    app_global_get_ex
    assert // check self.txn_fuel exists
    // smart_contracts/dualstakefarm/contract.py:562
    // return self.get_txn_fee_per_block() + self.get_ix_rewards_per_block()
    callsub get_txn_fee_per_block
    callsub get_ix_rewards_per_block
    +
    // smart_contracts/dualstakefarm/contract.py:390-391
    // # adjust txn fuel remaining
    // self.txn_fuel = self.txn_fuel + self.get_spend_per_block() * duration_blocks
    frame_dig -1
    *
    +
    bytec_1 // "txn_fuel"
    swap
    app_global_put
    // smart_contracts/dualstakefarm/contract.py:393
    // self.global_remaining_blocks = self.global_remaining_blocks + duration_blocks
    intc_1 // 0
    bytec_0 // "global_remaining_blocks"
    app_global_get_ex
    assert // check self.global_remaining_blocks exists
    frame_dig -1
    +
    bytec_0 // "global_remaining_blocks"
    swap
    app_global_put
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.extend_amount_per_block(recipient_app: uint64, amount_per_block: uint64) -> void:
extend_amount_per_block:
    // smart_contracts/dualstakefarm/contract.py:395-400
    // @abimethod
    // def extend_amount_per_block(
    //     self,
    //     recipient_app: Application,
    //     amount_per_block: UInt64,
    // ) -> None:
    proto 2 0
    // smart_contracts/dualstakefarm/contract.py:401
    // custom.ensure(recipient_app in self.farms, S("ERR:NO FARM"))
    frame_dig -2
    itob
    dup
    box_len
    bury 1
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz extend_amount_per_block_after_if_else@3
    // smart_contracts/dualstakefarm/contract.py:401
    // custom.ensure(recipient_app in self.farms, S("ERR:NO FARM"))
    bytec 6 // "ERR:NO FARM"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

extend_amount_per_block_after_if_else@3:
    // smart_contracts/dualstakefarm/contract.py:403
    // state = self.farms[recipient_app].copy()
    frame_dig 0
    dup
    box_get
    assert // check self.farms entry exists
    // smart_contracts/dualstakefarm/contract.py:404
    // farm_asset = Asset(state.farm_asset.native)
    dup
    extract 0 8 // on error: Index access is out of bounds
    btoi
    // smart_contracts/dualstakefarm/contract.py:407
    // Txn.group_index + UInt64(1),  # next txn
    txn GroupIndex
    intc_0 // 1
    +
    // smart_contracts/dualstakefarm/contract.py:409
    // amount_per_block * state.remaining_duration_blocks.native,
    dig 2
    extract 16 8 // on error: Index access is out of bounds
    btoi
    frame_dig -1
    *
    // smart_contracts/dualstakefarm/contract.py:406-410
    // validate.axfer_amount_exact(
    //     Txn.group_index + UInt64(1),  # next txn
    //     farm_asset,
    //     amount_per_block * state.remaining_duration_blocks.native,
    // )
    swap
    cover 2
    callsub axfer_amount_exact
    // smart_contracts/dualstakefarm/contract.py:414
    // state.amount_per_block.native + amount_per_block
    dup
    extract 8 8 // on error: Index access is out of bounds
    btoi
    frame_dig -1
    +
    // smart_contracts/dualstakefarm/contract.py:412-415
    // # adjust amount per block in state
    // state.amount_per_block = arc4.UInt64(
    //     state.amount_per_block.native + amount_per_block
    // )
    itob
    replace2 8
    // smart_contracts/dualstakefarm/contract.py:416-417
    // # save state
    // self.farms[recipient_app] = state.copy()
    box_put
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.payout(recipient_app: uint64, block_round: uint64, call_swap: bytes) -> void:
payout:
    // smart_contracts/dualstakefarm/contract.py:419-422
    // @abimethod()
    // def payout(
    //     self, recipient_app: Application, block_round: UInt64, call_swap: arc4.Bool
    // ) -> None:
    proto 3 0
    intc_1 // 0
    dup
    bytec_3 // ""
    // smart_contracts/dualstakefarm/contract.py:423-424
    // # ensure farm exists
    // custom.ensure(recipient_app in self.farms, S("ERR:NO FARM"))
    frame_dig -3
    itob
    dup
    box_len
    bury 1
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz payout_after_if_else@19
    // smart_contracts/dualstakefarm/contract.py:423-424
    // # ensure farm exists
    // custom.ensure(recipient_app in self.farms, S("ERR:NO FARM"))
    bytec 6 // "ERR:NO FARM"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

payout_after_if_else@19:
    // smart_contracts/dualstakefarm/contract.py:426-427
    // # load farm state
    // state = self.farms[recipient_app].copy()
    frame_dig 3
    box_get
    swap
    dup
    cover 2
    frame_bury 0
    assert // check self.farms entry exists
    // smart_contracts/dualstakefarm/contract.py:429-431
    // # ensure we have remaining blocks to pay out in this farm
    // # if not, delete farm state and return
    // if state.remaining_duration_blocks == 0:
    extract 16 8 // on error: Index access is out of bounds
    bytec 5 // 0x0000000000000000
    b==
    bz payout_after_if_else@2
    // smart_contracts/dualstakefarm/contract.py:432
    // del self.farms[recipient_app]
    frame_dig 3
    box_del
    pop
    // smart_contracts/dualstakefarm/contract.py:433-434
    // # TODO Emit event?
    // log("expired")
    pushbytes "expired"
    log
    // smart_contracts/dualstakefarm/contract.py:435
    // return
    retsub

payout_after_if_else@2:
    // smart_contracts/dualstakefarm/contract.py:437-438
    // # ensure our block is after the last block we have paid
    // custom.ensure(block_round > state.last_block_paid, S("ERR:PAST"))
    frame_dig 0
    extract 24 8 // on error: Index access is out of bounds
    frame_dig -2
    itob
    dup
    frame_bury 1
    b<
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz payout_after_if_else@11
    // smart_contracts/dualstakefarm/contract.py:437-438
    // # ensure our block is after the last block we have paid
    // custom.ensure(block_round > state.last_block_paid, S("ERR:PAST"))
    pushbytes "ERR:PAST"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

payout_after_if_else@11:
    // smart_contracts/dualstakefarm/contract.py:442
    // op.Block.blk_proposer(block_round) == recipient_app.address,
    frame_dig -2
    block BlkProposer
    frame_dig -3
    app_params_get AppAddress
    assert // application exists
    ==
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz payout_after_if_else@15
    // smart_contracts/dualstakefarm/contract.py:443
    // S("ERR:NOT BLK PROP"),
    pushbytes "ERR:NOT BLK PROP"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

payout_after_if_else@15:
    // smart_contracts/dualstakefarm/contract.py:449-450
    // # call swap if needed
    // if call_swap:
    frame_dig -1
    pushbytes 0x00
    !=
    bz payout_after_if_else@5
    // smart_contracts/dualstakefarm/contract.py:451-455
    // abi_call(
    //     "swap_or_fail()void",
    //     app_id=recipient_app,
    //     fee=Global.min_txn_fee,
    // )
    itxn_begin
    // smart_contracts/dualstakefarm/contract.py:454
    // fee=Global.min_txn_fee,
    global MinTxnFee
    frame_dig -3
    itxn_field ApplicationID
    // smart_contracts/dualstakefarm/contract.py:451-455
    // abi_call(
    //     "swap_or_fail()void",
    //     app_id=recipient_app,
    //     fee=Global.min_txn_fee,
    // )
    pushbytes 0x93239802 // method "swap_or_fail()void"
    itxn_field ApplicationArgs
    pushint 6 // appl
    itxn_field TypeEnum
    itxn_field Fee
    itxn_submit

payout_after_if_else@5:
    // smart_contracts/dualstakefarm/contract.py:457-458
    // # subtract txn fuel regardless of call swap or not
    // txn_fuel_spent = txn_fuel_spent + Global.min_txn_fee
    global MinTxnFee
    // smart_contracts/dualstakefarm/contract.py:462
    // Asset(state.farm_asset.native),
    frame_dig 0
    dup
    extract 0 8 // on error: Index access is out of bounds
    btoi
    // smart_contracts/dualstakefarm/contract.py:463
    // recipient_app.address,
    frame_dig -3
    app_params_get AppAddress
    assert // application exists
    // smart_contracts/dualstakefarm/contract.py:464
    // state.amount_per_block.native,
    dig 2
    extract 8 8 // on error: Index access is out of bounds
    btoi
    // smart_contracts/dualstakefarm/contract.py:465
    // Global.min_txn_fee,
    global MinTxnFee
    // smart_contracts/dualstakefarm/contract.py:460-466
    // # pay out reward
    // send.axfer(
    //     Asset(state.farm_asset.native),
    //     recipient_app.address,
    //     state.amount_per_block.native,
    //     Global.min_txn_fee,
    // )
    callsub axfer
    // smart_contracts/dualstakefarm/contract.py:467
    // txn_fuel_spent = txn_fuel_spent + Global.min_txn_fee
    global MinTxnFee
    uncover 2
    +
    // smart_contracts/dualstakefarm/contract.py:469-470
    // # send ix reward
    // send.algo_pay(Txn.sender, self.get_ix_rewards_per_block(), Global.min_txn_fee)
    txn Sender
    callsub get_ix_rewards_per_block
    global MinTxnFee
    callsub algo_pay
    // smart_contracts/dualstakefarm/contract.py:472
    // txn_fuel_spent + Global.min_txn_fee + self.get_ix_rewards_per_block()
    global MinTxnFee
    +
    callsub get_ix_rewards_per_block
    +
    // smart_contracts/dualstakefarm/contract.py:471-473
    // txn_fuel_spent = (
    //     txn_fuel_spent + Global.min_txn_fee + self.get_ix_rewards_per_block()
    // )
    frame_bury 2
    // smart_contracts/dualstakefarm/contract.py:475-476
    // # update box state
    // state.last_block_paid = arc4.UInt64(block_round)
    frame_dig 1
    replace2 24
    // smart_contracts/dualstakefarm/contract.py:478
    // state.remaining_duration_blocks.native - UInt64(1)
    dup
    extract 16 8 // on error: Index access is out of bounds
    btoi
    intc_0 // 1
    -
    // smart_contracts/dualstakefarm/contract.py:477-479
    // state.remaining_duration_blocks = arc4.UInt64(
    //     state.remaining_duration_blocks.native - UInt64(1)
    // )
    itob
    replace2 16
    dup
    frame_bury 0
    // smart_contracts/dualstakefarm/contract.py:480
    // if state.remaining_duration_blocks == 0:
    extract 16 8 // on error: Index access is out of bounds
    bytec 5 // 0x0000000000000000
    b==
    bz payout_else_body@7
    // smart_contracts/dualstakefarm/contract.py:481
    // del self.farms[recipient_app]
    frame_dig 3
    box_del
    pop

payout_after_if_else@8:
    // smart_contracts/dualstakefarm/contract.py:485-486
    // # update global txn fuel state
    // self.txn_fuel = self.txn_fuel - txn_fuel_spent
    intc_1 // 0
    bytec_1 // "txn_fuel"
    app_global_get_ex
    assert // check self.txn_fuel exists
    frame_dig 2
    -
    bytec_1 // "txn_fuel"
    swap
    app_global_put
    // smart_contracts/dualstakefarm/contract.py:487
    // self.global_remaining_blocks = self.global_remaining_blocks - 1
    intc_1 // 0
    bytec_0 // "global_remaining_blocks"
    app_global_get_ex
    assert // check self.global_remaining_blocks exists
    intc_0 // 1
    -
    bytec_0 // "global_remaining_blocks"
    swap
    app_global_put
    retsub

payout_else_body@7:
    // smart_contracts/dualstakefarm/contract.py:483
    // self.farms[recipient_app] = state.copy()
    frame_dig 3
    frame_dig 0
    box_put
    b payout_after_if_else@8


// smart_contracts.dualstakefarm.contract.DualstakeFarm.withdraw_fees(amount: uint64) -> void:
withdraw_fees:
    // smart_contracts/dualstakefarm/contract.py:493-494
    // @abimethod
    // def withdraw_fees(self, amount: UInt64) -> None:
    proto 1 0
    // smart_contracts/dualstakefarm/contract.py:495
    // self.ensure_manager_caller()
    callsub ensure_manager_caller
    // smart_contracts/dualstakefarm/contract.py:496
    // locked_balance = Global.current_application_address.min_balance + (
    global CurrentApplicationAddress
    acct_params_get AcctMinBalance
    assert // account funded
    // smart_contracts/dualstakefarm/contract.py:497
    // self.global_remaining_blocks * self.get_spend_per_block()
    intc_1 // 0
    bytec_0 // "global_remaining_blocks"
    app_global_get_ex
    assert // check self.global_remaining_blocks exists
    // smart_contracts/dualstakefarm/contract.py:562
    // return self.get_txn_fee_per_block() + self.get_ix_rewards_per_block()
    callsub get_txn_fee_per_block
    callsub get_ix_rewards_per_block
    +
    // smart_contracts/dualstakefarm/contract.py:497
    // self.global_remaining_blocks * self.get_spend_per_block()
    *
    // smart_contracts/dualstakefarm/contract.py:496-498
    // locked_balance = Global.current_application_address.min_balance + (
    //     self.global_remaining_blocks * self.get_spend_per_block()
    // )
    +
    // smart_contracts/dualstakefarm/contract.py:500
    // locked_balance + amount <= Global.current_application_address.balance,
    frame_dig -1
    +
    global CurrentApplicationAddress
    acct_params_get AcctBalance
    assert // account funded
    <=
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz withdraw_fees_after_if_else@5
    // smart_contracts/dualstakefarm/contract.py:501
    // S("ERR:OVER"),
    pushbytes "ERR:OVER"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

withdraw_fees_after_if_else@5:
    // smart_contracts/dualstakefarm/contract.py:504
    // Txn.sender,
    txn Sender
    // smart_contracts/dualstakefarm/contract.py:503-507
    // send.algo_pay(
    //     Txn.sender,
    //     amount,
    //     UInt64(0),
    // )
    frame_dig -1
    // smart_contracts/dualstakefarm/contract.py:506
    // UInt64(0),
    intc_1 // 0
    // smart_contracts/dualstakefarm/contract.py:503-507
    // send.algo_pay(
    //     Txn.sender,
    //     amount,
    //     UInt64(0),
    // )
    callsub algo_pay
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.optout(asset: uint64) -> void:
optout:
    // smart_contracts/dualstakefarm/contract.py:509-510
    // @abimethod
    // def optout(self, asset: Asset) -> None:
    proto 1 0
    // smart_contracts/dualstakefarm/contract.py:511
    // self.ensure_manager_caller()
    callsub ensure_manager_caller
    // smart_contracts/dualstakefarm/contract.py:513
    // Global.current_application_address.is_opted_in(asset), S("ERR:NOT OPTED")
    global CurrentApplicationAddress
    frame_dig -1
    asset_holding_get AssetBalance
    bury 1
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz optout_after_if_else@3
    // smart_contracts/dualstakefarm/contract.py:513
    // Global.current_application_address.is_opted_in(asset), S("ERR:NOT OPTED")
    pushbytes "ERR:NOT OPTED"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

optout_after_if_else@3:
    // smart_contracts/dualstakefarm/contract.py:516
    // asset.balance(Global.current_application_address) == 0, S("ERR:BALANCE")
    global CurrentApplicationAddress
    frame_dig -1
    asset_holding_get AssetBalance
    assert // account opted into asset
    // smart_contracts/common/custom.py:11
    // if not cond:
    bz optout_after_if_else@7
    // smart_contracts/dualstakefarm/contract.py:516
    // asset.balance(Global.current_application_address) == 0, S("ERR:BALANCE")
    pushbytes "ERR:BALANCE"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

optout_after_if_else@7:
    // smart_contracts/dualstakefarm/contract.py:518
    // send.axfer_closeout(asset, self.manager, UInt64(0))
    intc_1 // 0
    bytec 4 // "manager"
    app_global_get_ex
    assert // check self.manager exists
    // smart_contracts/common/send.py:28-34
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=receiver,
    //     asset_amount=0,
    //     asset_close_to=receiver,
    //     fee=fee,
    // ).submit()
    itxn_begin
    dup
    itxn_field AssetCloseTo
    // smart_contracts/common/send.py:31
    // asset_amount=0,
    intc_1 // 0
    itxn_field AssetAmount
    itxn_field AssetReceiver
    frame_dig -1
    itxn_field XferAsset
    // smart_contracts/common/send.py:28
    // itxn.AssetTransfer(
    pushint 4 // axfer
    itxn_field TypeEnum
    // smart_contracts/dualstakefarm/contract.py:518
    // send.axfer_closeout(asset, self.manager, UInt64(0))
    intc_1 // 0
    itxn_field Fee
    // smart_contracts/common/send.py:28-34
    // itxn.AssetTransfer(
    //     xfer_asset=asset,
    //     asset_receiver=receiver,
    //     asset_amount=0,
    //     asset_close_to=receiver,
    //     fee=fee,
    // ).submit()
    itxn_submit
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.update_max_duration_days(max_duration: uint64) -> void:
update_max_duration_days:
    // smart_contracts/dualstakefarm/contract.py:520-521
    // @abimethod
    // def update_max_duration_days(self, max_duration: UInt64) -> None:
    proto 1 0
    // smart_contracts/dualstakefarm/contract.py:522
    // self.ensure_manager_caller()
    callsub ensure_manager_caller
    // smart_contracts/dualstakefarm/contract.py:523
    // self.max_duration_days = max_duration
    bytec 7 // "max_duration_days"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.update_min_duration_blocks(min_duration: uint64) -> void:
update_min_duration_blocks:
    // smart_contracts/dualstakefarm/contract.py:525-526
    // @abimethod
    // def update_min_duration_blocks(self, min_duration: UInt64) -> None:
    proto 1 0
    // smart_contracts/dualstakefarm/contract.py:527
    // self.ensure_manager_caller()
    callsub ensure_manager_caller
    // smart_contracts/dualstakefarm/contract.py:528
    // self.min_duration_blocks = min_duration
    bytec 8 // "min_duration_blocks"
    frame_dig -1
    app_global_put
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.get_state(recipient_app: uint64) -> bytes:
get_state:
    // smart_contracts/dualstakefarm/contract.py:530-531
    // @abimethod(readonly=True)
    // def get_state(self, recipient_app: Application) -> FarmState:
    proto 1 1
    // smart_contracts/dualstakefarm/contract.py:532
    // return self.farms[recipient_app]
    frame_dig -1
    itob
    box_get
    assert // check self.farms entry exists
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.log_states(box_names: bytes) -> void:
log_states:
    // smart_contracts/dualstakefarm/contract.py:534-535
    // @abimethod(readonly=True)
    // def log_states(self, box_names: arc4.DynamicArray[arc4.UInt64]) -> None:
    proto 1 0
    intc_1 // 0
    // smart_contracts/dualstakefarm/contract.py:536
    // for k in urange(box_names.length):
    frame_dig -1
    intc_1 // 0
    extract_uint16
    intc_1 // 0

log_states_for_header@1:
    // smart_contracts/dualstakefarm/contract.py:536
    // for k in urange(box_names.length):
    frame_dig 2
    frame_dig 1
    <
    bz log_states_after_for@7
    // smart_contracts/dualstakefarm/contract.py:537
    // box_name = Application(box_names[k].native)
    frame_dig -1
    extract 2 0
    frame_dig 2
    intc_2 // 8
    *
    intc_2 // 8
    extract3 // on error: Index access is out of bounds
    btoi
    // smart_contracts/dualstakefarm/contract.py:538
    // if box_name in self.farms:
    itob
    dup
    frame_bury 0
    box_len
    bury 1
    bz log_states_else_body@4
    // smart_contracts/dualstakefarm/contract.py:539
    // log(self.farms[box_name])
    frame_dig 0
    box_get
    assert // check self.farms entry exists
    log

log_states_after_if_else@5:
    // smart_contracts/dualstakefarm/contract.py:536
    // for k in urange(box_names.length):
    frame_dig 2
    intc_0 // 1
    +
    frame_bury 2
    b log_states_for_header@1

log_states_else_body@4:
    // smart_contracts/dualstakefarm/contract.py:541
    // log(FarmState.from_bytes(b""))
    bytec_3 // 0x
    log
    b log_states_after_if_else@5

log_states_after_for@7:
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.log_block_proposers(start_round: uint64, end_round: uint64) -> void:
log_block_proposers:
    // smart_contracts/dualstakefarm/contract.py:543-544
    // @abimethod(readonly=True)
    // def log_block_proposers(self, start_round: UInt64, end_round: UInt64) -> None:
    proto 2 0
    // smart_contracts/dualstakefarm/contract.py:545
    // for rnd in urange(start_round, end_round + 1):
    frame_dig -1
    intc_0 // 1
    +
    frame_dig -2

log_block_proposers_for_header@1:
    // smart_contracts/dualstakefarm/contract.py:545
    // for rnd in urange(start_round, end_round + 1):
    frame_dig 1
    frame_dig 0
    <
    bz log_block_proposers_after_for@4
    // smart_contracts/dualstakefarm/contract.py:546
    // log(op.Block.blk_proposer(rnd))
    frame_dig 1
    dup
    block BlkProposer
    log
    // smart_contracts/dualstakefarm/contract.py:545
    // for rnd in urange(start_round, end_round + 1):
    intc_0 // 1
    +
    frame_bury 1
    b log_block_proposers_for_header@1

log_block_proposers_after_for@4:
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.ensure_manager_caller() -> void:
ensure_manager_caller:
    // smart_contracts/dualstakefarm/contract.py:548-549
    // @subroutine
    // def ensure_manager_caller(self) -> None:
    proto 0 0
    // smart_contracts/dualstakefarm/contract.py:550
    // custom.ensure(Txn.sender == self.manager, S("ERR:UNAUTH"))
    txn Sender
    intc_1 // 0
    bytec 4 // "manager"
    app_global_get_ex
    assert // check self.manager exists
    ==
    // smart_contracts/common/custom.py:11
    // if not cond:
    bnz ensure_manager_caller_after_if_else@3
    // smart_contracts/dualstakefarm/contract.py:550
    // custom.ensure(Txn.sender == self.manager, S("ERR:UNAUTH"))
    pushbytes "ERR:UNAUTH"
    // smart_contracts/common/custom.py:12
    // log(msg)
    log
    // smart_contracts/common/custom.py:13
    // op.err()
    err

ensure_manager_caller_after_if_else@3:
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.get_ix_rewards_per_block() -> uint64:
get_ix_rewards_per_block:
    // smart_contracts/dualstakefarm/contract.py:564-565
    // @subroutine
    // def get_ix_rewards_per_block(self) -> UInt64:
    proto 0 1
    // smart_contracts/dualstakefarm/contract.py:566
    // return self.ix_pb * Global.min_txn_fee
    intc_1 // 0
    bytec 9 // "ix_pb"
    app_global_get_ex
    assert // check self.ix_pb exists
    global MinTxnFee
    *
    retsub


// smart_contracts.dualstakefarm.contract.DualstakeFarm.get_txn_fee_per_block() -> uint64:
get_txn_fee_per_block:
    // smart_contracts/dualstakefarm/contract.py:572-573
    // @subroutine
    // def get_txn_fee_per_block(self) -> UInt64:
    proto 0 1
    // smart_contracts/dualstakefarm/contract.py:574
    // return self.txn_fee_pb * Global.min_txn_fee
    intc_1 // 0
    bytec 11 // "txn_fee_pb"
    app_global_get_ex
    assert // check self.txn_fee_pb exists
    global MinTxnFee
    *
    retsub
